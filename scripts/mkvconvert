#!/usr/bin/env bash
#
# mkvconvert ‚Äî Smart MKV converter for browser compatibility
# Chooses WebM or MP4 automatically based on codecs.
#
# Logic:
#  - If video is VP8/VP9/AV1 ‚Üí output WebM
#    - If audio is Opus/Vorbis ‚Üí remux
#    - Else re-encode audio to Opus
#  - If video is H.264 ‚Üí output MP4
#    - If audio is AAC ‚Üí remux
#    - Else re-encode audio to AAC
#  - Otherwise ‚Üí re-encode to VP9+Opus (WebM)
#
# Usage: mkvconvert input.mkv [output]
#        mkvconvert *.mkv
#

set -e

if [ -z "$1" ]; then
  echo "Usage: mkvconvert input.mkv [output]"
  echo "       mkvconvert *.mkv"
  exit 1
fi

# Function to process a single file
process_file() {
  local INPUT="$1"
  local OUTPUT="$2"

  if [ ! -f "$INPUT" ]; then
    echo "Error: File '$INPUT' not found."
    return 1
  fi

  # Extract codecs
  VIDEO_CODEC=$(ffprobe -v error -select_streams v:0 -show_entries stream=codec_name \
    -of default=noprint_wrappers=1:nokey=1 "$INPUT" | tr '[:upper:]' '[:lower:]')

  AUDIO_CODEC=$(ffprobe -v error -select_streams a:0 -show_entries stream=codec_name \
    -of default=noprint_wrappers=1:nokey=1 "$INPUT" | tr '[:upper:]' '[:lower:]')

  echo "Processing: $INPUT"
  echo "Detected video codec: $VIDEO_CODEC"
  echo "Detected audio codec: $AUDIO_CODEC"

  # Decide container and conversion strategy
  if [[ "$VIDEO_CODEC" =~ ^(vp8|vp9|av1)$ ]]; then
    CONTAINER="webm"
    if [[ "$AUDIO_CODEC" =~ ^(opus|vorbis)$ ]]; then
      MODE="remux"
      OUTPUT="${OUTPUT:-${INPUT%.*}.webm}"
    else
      MODE="audio-reencode"
      OUTPUT="${OUTPUT:-${INPUT%.*}.webm}"
    fi

  elif [[ "$VIDEO_CODEC" =~ ^(h264|av1|hevc|h265)$ ]]; then
    CONTAINER="mp4"
    if [[ "$AUDIO_CODEC" =~ ^(aac|mp3|opus|alac)$ ]]; then
      MODE="remux"
      OUTPUT="${OUTPUT:-${INPUT%.*}.mp4}"
    else
      MODE="audio-reencode"
      OUTPUT="${OUTPUT:-${INPUT%.*}.mp4}"
    fi

  else
    CONTAINER="webm"
    MODE="full-reencode"
    OUTPUT="${OUTPUT:-${INPUT%.*}.webm}"
  fi

  echo "Target container: $CONTAINER"
  echo "Conversion mode: $MODE"

  # Run ffmpeg with the right strategy
  case "$MODE" in
    remux)
      echo "‚úÖ Remuxing without re-encoding..."
      ffmpeg -hide_banner -loglevel error -i "$INPUT" -c copy -sn -map 0 "$OUTPUT"
      ;;
    audio-reencode)
      if [ "$CONTAINER" = "webm" ]; then
        echo "üéß Re-encoding audio to Opus..."
        ffmpeg -hide_banner -loglevel error -i "$INPUT" -c:v copy -c:a libopus -b:a 128k -sn -map 0 "$OUTPUT"
      else
        echo "üéß Re-encoding audio to AAC..."
        ffmpeg -hide_banner -loglevel error -i "$INPUT" -c:v copy -c:a aac -b:a 128k -sn -map 0 "$OUTPUT"
      fi
      ;;
    full-reencode)
      echo "‚öôÔ∏è Re-encoding video to VP9 + Opus for full WebM compatibility..."
      ffmpeg -hide_banner -loglevel error -i "$INPUT" \
        -c:v libvpx-vp9 -b:v 6M -c:a libopus -b:a 128k -sn -map 0 "$OUTPUT"
      ;;
  esac

  echo "‚úÖ Done! Output saved to: $OUTPUT"
  echo ""
}

# Main: process all arguments as input files
# Wildcards like "*.mkv" are expanded by the shell before reaching this script
for file in "$@"; do
  if [ -f "$file" ]; then
    # Temporarily disable exit on error for this iteration
    set +e
    process_file "$file" ""
    set -e
  else
    echo "Warning: '$file' is not a file, skipping..."
  fi
done
